module Task3_3 where

{-
  Задание 3.3
  Множество на основе предикатов
-}

newtype PSet a = PSet{ contains :: (a -> Bool) }

-- Реализуйте классы Monoid и Functor
-- Объясните в комментариях, почему они реализованы именно так

{-Пусть объединениям двух множеств будет соответсвовать их пересечение,
т.е. логическое "И"
-}
instance Semigroup (PSet a) where
    (<>) f1 f2 = PSet (\x -> ((contains f1) x) && ((contains f2) x))             

{- Пустое множество <=> предикат не выполняется ни для какого эл-та
<=> - "эквивалетно" -}
instance Monoid (PSet a) where
    mempty = PSet (const False)

{- Тип параметра "а" контейнера PSet не известен, из за чего
 невозможно применить передаваемую в fmap ф-цию f к данным внутри
 контейнера (f inF), т.к. невозможно проверить что аргумент полученный 
 ф-ции, упаковываемой в контейнер будет соответствовать типу "a".
 Upd. - в добавок, передаваемая в функтор ф-ция f лишь говорит о том, 
 какой тип должен быть упакован внутрь контейнера, но ни коим образом
 не определяет возвращаемое значение 
-}

instance Functor PSet where
    fmap f (PSet c) = PSet (\x -> False)
    